
1.Me he planteado dos posibles cargas de los json, ya que que probablemente en casos reales sean llamadas a WebApis:
  a) Inicialización en el propio constructor del Store.
       Ventaja: Se carga al principio de la aplicación y ya se tiene cacheado en el propio store.
       Desventaja: Se carga aunque el componente no se instancie nunca, con el tiempo y consumo de memoria innecesario en estos casos.

  b) Inicialización en el ngOnInit del componente que consume el Store.
       Ventaja: Solo se dedica tiempo y memoria cuando se inicializa el componente
       Desventaja: Existe una demora en la carga inicial del componente.

Entiendo que si el Stores se consume desde multiples componentes es más eficaz el caso primero, y para casos sencillos como el del ejercicio es mejor el segundo.

He presentado el ejercicio con el primer caso y así solo he necesitado dos acciones, ya que el store se incializa solo.

2. Como los arrays cacheados de estados, agencias y tipos de misión forman parte del estado, cada llamada al reducer los copia y
   aunque el estado anterior se destruye al sobreescribirse con la nueva copia modificada del reducer y no hay doble ocupación de memoria, si se produce
   un coste de copia a mi juicio innecesario. En nuestro caso el array mas voluminoso es el de lanzamientos, pero en casos reales puede ser mayor.

  Dudas: ¿es aceptable realizar una actualización parcial del estado?
        ¿se podría dejar "aparte" los arrays cacheados para no dedicar tiempo a su copia?
        ¿el patron redux tiene otro enfoque para los 'datos cacheables'?

 3. Con el pipe async y los observables por slices no es realmente necesario usar los snapshots, aunque el enunciado nos conduce a ello.
    He forzado el uso de snapshots solo en los valores 'fijos' de tipos de criterios.